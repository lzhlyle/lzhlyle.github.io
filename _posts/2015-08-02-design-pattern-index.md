---
layout:     post
title:      一句话的设计模式
subtitle:   看一眼就快速回想起该设计模式的种种记忆
date:       2015-08-02
author:     lyle
header-img: "img/in-post/design-pattern-index/post-bg-design-pattern-index.jpg"
tags:
    - 学习笔记
    - 设计模式
---

如题，实际上，我想这是很困难的。

除非——只是为了给自己做一个提醒，能够看一眼就快速回想起该设计模式的种种记忆。

下列是我之前在学习《大话设计模式》时做的笔记总结，当中有部分措辞来自其作者程杰。（非常感谢他为神秘的设计模式搭建了如此平滑的学习通道）

## 创建型

1. **单例**：只需一个实例时考虑。
2. **工厂方法**：一般先用工厂方法解决对象创建问题。
3. **抽象工厂**：当工厂方法无法满足多系列问题时，再重构为抽象工厂。
4. **建造者**：多个部件的建造实现相同，只是所需部件、建造顺序不同时考虑。
5. **原型**：在初始化信息不发生变化时考虑。


## 结构型

1. **适配器**：让接口不相容的类能协同工作。（亡羊补牢）
2. **装饰**：动态增加单个对象的额外职责，比生成子类更灵活。
3. **桥接**：使继承关系更改为组合关系，使两者可独立变化。（未雨绸缪）
4. **组合**：用树状结构表示“整体-部分”的层次关系，使单个对象（叶节点）与组合对象（枝节点）的使用具有一致性。
5. **享元**：为运用共享技术，支持大量细粒度对象，节省开销。
6. **代理**：控制对单个对象的访问。
7. **外观**：子系统的高层接口，避免两个类直接关系的第三者。

## 行为型

1. **观察者**：一对多依赖关系，一端变化、多端得到通知并自动更新。（目标与观察者可实现弱耦合）
2. 模板方法：继承+重写解决代码重复问题。
3. **命令**：将请求发送者与具体实现者解耦，可对请求排列、取消、重做，支持事务。（多请求，单处理）
4. **职责链**：将处理者排成链，沿链传递请求。（单请求，多处理）
5. **状态**：当对象内状态改变而执行不同操作时考虑，状态转移逻辑不在if/switch中，而在各子类之间，增/改状态和状态转换较容易。
6. **解释器**：若某特定问题发生的频率足够高时考虑，需定义文法表示与解释器本身。
7. **中介者**：由中介封装一系列对象交互，减少对象间耦合，利于复用。（朋友多）
8. **访问者**：当Element较稳定、Visitor易增加时考虑。（朋友在精不在多）
9. **策略**：将一系列算法逐个封装并可相互替换，易于切换、理解、扩展。
10. **备忘录**：不破坏封装，又要取该对象内状态，且要求状态还原时考虑。（保持封装边界）
11. **迭代器**：将对集合的访问与遍历从集合对象中分离出来到迭代器中。

*[首发博客](https://www.cnblogs.com/lzhlyle/p/4696645.html)*
