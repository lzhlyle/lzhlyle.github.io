---
layout:     post
title:      思路要稳步推进，跨步太大会扯着
subtitle:   LeetCode 第 203 场周赛
date:       2020-08-23
author:     lyle
header-img: "img/in-post/leetcode-contest-weekly-203/banner.jpg"
tags:
    - LeetCode 竞赛
---

本周周赛出的挺好的，每道题都需要在理解的基础上稍微转个弯。无奈 T3，T4 赛中没做出来，一闪而过的思路没有坚持，总想着一步到位：该了您内。

> 7 分，1000+ 名

## 题目

1. [圆形赛道上经过次数最多的扇区](#t1-圆形赛道上经过次数最多的扇区)
2. 
3. 
4. 
5. [赛后复盘](#赛后复盘)

## T1. 圆形赛道上经过次数最多的扇区

#### 题目

> 给你一个整数 `n` 和一个整数数组 `rounds` 。有一条圆形赛道由 `n` 个扇区组成，扇区编号从 `1` 到 `n` 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 `m` 个阶段组成。其中，第 `i` 个阶段将会从扇区 `rounds[i - 1]` 开始，到扇区 `rounds[i]` 结束。举例来说，第 `1` 阶段从 `rounds[0]` 开始，到 `rounds[1]` 结束。
> 
> 请你以数组形式返回经过次数最多的扇区，按扇区编号 **升序** 排列。
> 
> 注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。

示例 1

![t1 eg1](/img/in-post/leetcode-contest-weekly-203/t1-eg1.jpg)

```
输入：n = 4, rounds = [1,3,1,2]
输出：[1,2]
解释：本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示：
1 --> 2 --> 3（阶段 1 结束）
  --> 4 --> 1（阶段 2 结束）
  --> 2（阶段 3 结束，即本场马拉松结束）
其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。
扇区 3 和 4 都只经过了一次。
```

示例 2

```
输入：n = 2, rounds = [2,1,2,1,2,1,2,1,2]
输出：[2]
```

示例 3

```
输入：n = 7, rounds = [1,3,5,7]
输出：[1,2,3,4,5,6,7]
```

提示

- `2 <= n <= 100`
- `1 <= m <= 100`
- `rounds.length == m + 1`
- `1 <= rounds[i] <= n`
- `rounds[i] != rounds[i + 1]`，其中 `0 <= i < m`

#### 题解思路

- `rounds`（个人习惯，改为 `arr`）为接力棒的人所在位置
- 从 `arr[0]` 开始跑，到 `ax = arr[n - 1]` 结束，求讲过最多的区域
- 形如 `y = tan(x) ` 的曲线
    - `arr[0]` 即与 `Y` 轴交点 `(0, arr[0])`，开始向上跑
    - 最终会跑到与 `x = n - 1` 纵线的交点 `(n - 1, arr[n - 1])`
    - 中间所有从 `1` 到 `n` 的上坡路次数都相同
    - **只需关注头尾两段斜坡**
    - 头斜坡 `[arr[0], n]`，尾斜坡 `[1, arr[n - 1]]`

![t1 eg1](/img/in-post/leetcode-contest-weekly-203/t1-tan.jpg)

#### 参考代码

```java
public List<Integer> mostVisited(int n, int[] arr) {
    int a0 = arr[0], ax = arr[arr.length - 1]; // 头尾交点
    if (a0 == ax) return Collections.singletonList(a0); // a0 恰为重叠处
    
    List<Integer> res = new ArrayList<>();
    if (a0 > ax) { // 无重叠，两段都算
        for (int v = 1; v <= ax; v++) res.add(v);
        for (int v = a0; v <= n; v++) res.add(v);
        return res;
    }
    
    // a0 < ax，有重叠，只算重叠部分
    for (int v = a0; v <= ax; v++) res.add(v);
    return res;
}
```

#### 复杂度分析

- 时间复杂度：`O(n)`，`n` 为 参数 `n`，而非 `arr.length`
- 空间复杂度：`O(1)`，不计返回值

## T2. 

#### 题目

#### 题解思路

#### 参考代码

```java

```

#### 复杂度分析

- 时间复杂度：
- 空间复杂度：

## T3. 

#### 题目

#### 题解思路

#### 参考代码

```java

```

#### 复杂度分析

- 时间复杂度：
- 空间复杂度：

## T4. 

#### 题目

#### 题解思路

#### 参考代码

```java

```

#### 复杂度分析

- 时间复杂度：
- 空间复杂度：

## 赛后复盘

- T1 
- T2 
- T3 
- T4 


